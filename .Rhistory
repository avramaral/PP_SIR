for (t in ts) {
fitted_values[[t]] <- result$summary.fitted.values[((t - 1) * N_sp + 1):((t) * N_sp), quant]  / (cellarea * cellarea)
result_r_0250[[t]] <- convert_result(area_pop = area_pop, values = fitted_values[[t]][, 1], n_row_count = n_row_count, n_col_count = n_col_count)
result_r_0975[[t]] <- convert_result(area_pop = area_pop, values = fitted_values[[t]][, 2], n_row_count = n_row_count, n_col_count = n_col_count)
result_r_mean[[t]] <- convert_result(area_pop = area_pop, values = fitted_values[[t]][, 3], n_row_count = n_row_count, n_col_count = n_col_count)
}
list(result_r_0250 = result_r_0250, result_r_0975 = result_r_0975, result_r_mean = result_r_mean)
}
e
processed_result <- process_result(result = result, area_pop = area_pop, n_row_count = n_row_count, n_col_count = n_col_count) # Unchanged
plot(processed_result$result_r_mean[[20]])
process_result <- function (result, area_pop, n_row_count, n_col_count) {
N_sp <- n_row_count * n_col_count
ts <- 1:(nrow(result$summary.fitted.values) / N_sp)
cellarea <- prod(res(area_pop)) / ((n_row_count / nrow(area_pop)) * (n_col_count / ncol(area_pop)))
convert_result <- function (area_pop, values, n_row_count, n_col_count) {
r <- raster(nrow = n_row_count, ncol = n_col_count)
extent(r) <- extent(area_pop)
mult_factor <- (n_row_count / nrow(area_pop)) * (n_col_count / ncol(area_pop))
values(r) <- raster::extract(x = area_pop, y = rasterToPoints(r)) /  mult_factor
m <- matrix(data = values(r), nrow = n_row_count, ncol = n_col_count, byrow = TRUE)
v <- as.vector(m)
v[which(!is.na(values(r)))] <- values
m <- matrix(data = v, nrow = n_row_count, ncol = n_col_count)
values(r) <- m
r
}
quant <- c('0.025quant', '0.975quant', 'mean')
fitted_values <- list()
result_r_0250 <- list()
result_r_0975 <- list()
result_r_mean <- list()
for (t in ts) {
fitted_values[[t]] <- result$summary.fitted.values[((t - 1) * N_sp + 1):((t) * N_sp), quant]  / cellarea
result_r_0250[[t]] <- convert_result(area_pop = area_pop, values = fitted_values[[t]][, 1], n_row_count = n_row_count, n_col_count = n_col_count)
result_r_0975[[t]] <- convert_result(area_pop = area_pop, values = fitted_values[[t]][, 2], n_row_count = n_row_count, n_col_count = n_col_count)
result_r_mean[[t]] <- convert_result(area_pop = area_pop, values = fitted_values[[t]][, 3], n_row_count = n_row_count, n_col_count = n_col_count)
}
list(result_r_0250 = result_r_0250, result_r_0975 = result_r_0975, result_r_mean = result_r_mean)
}
fit_spatioTemporal <- function (area_pop, count_cells, Y_hat, prop_class, N_restricted, n_row_count = 10, n_col_count = 30, null_model = TRUE, AR_include = FALSE, verbose = FALSE) {
ts <- 1:length(count_cells[[1]])
n_classes <- length(prop_class)
convert_counts <- function (ts, area_pop, count_cells, n_classes, N_restricted, n_row_count, n_col_count) {
N <- length(count_cells[[1]])
ts <- ts[1:N_restricted]
final_counts <- c()
for (k in 1:n_classes) {
progressbar <- txtProgressBar(min = 1, max = length(ts), initial = 1)
counts <- c()
for (t in ts) {
r <- raster(nrow = n_row_count, ncol = n_col_count)
extent(r) <- extent(area_pop)
r <- rasterize(x = count_cells[[k]][[t]], y = r, field = 'layer')
m <- matrix(data = values(r), nrow = n_row_count, ncol = n_col_count, byrow = TRUE)
counts <- c(counts, na.omit(as.vector(m)))
setTxtProgressBar(progressbar, t)
}
close(progressbar)
counts <- c(counts, rep(NA, nrow(count_cells[[k]][[1]]) * (N - length(ts))))
final_counts <- c(final_counts, counts)
}
final_counts
}
convert_infect <- function (Y_hat, N_sp, N_cl) {
Y_hat_cp <- Y_hat
infect <- c()
for (k in 1:N_cl) {
Y_hat <- Y_hat_cp[, , c(k, (N_cl + k), (N_cl * 2 + k))]
infect <- c(infect, rep(apply(Y_hat, c(2, 3), mean)[, 2], each = N_sp))
}
infect
}
convert_pop <- function (area_pop, prop_class, N_tm, N_cl, n_row_count, n_col_count) {
final_v <- c()
for (k in 1:N_cl) {
area_pop_tmp <- area_pop
values(area_pop_tmp) <- values(area_pop) * prop_class[k]
r <- raster(nrow = n_row_count, ncol = n_col_count)
extent(r) <- extent(area_pop_tmp)
mult_factor <- ((n_row_count / nrow(area_pop_tmp)) * (n_col_count / ncol(area_pop_tmp)))
m <- matrix(data = raster::extract(x = area_pop_tmp, y = rasterToPoints(r)), nrow = n_row_count, ncol = n_col_count, byrow = TRUE) / mult_factor
v <- na.omit(as.vector(m))
v <- rep(v, N_tm)
final_v <- c(final_v, v / sum(v, na.rm = TRUE))
}
final_v
}
id_sp <- 1:nrow(count_cells[[1]][[1]]); N_sp <- length(id_sp)
id_tm <- ts; N_tm <- length(id_tm)
id_cl <- 1:n_classes; N_cl <- length(id_cl)
cellarea <- prod(res(area_pop)) / ((n_row_count / nrow(area_pop)) * (n_col_count / ncol(area_pop)))
print('Creating data object...')
data_INLA <- data.frame(id = 1:(N_sp * N_tm * N_cl),
id_sp = rep(id_sp, N_tm * N_cl),
id_tm = rep(rep(id_tm, each = N_sp), N_cl),
id_tm2 = rep(rep(id_tm, each = N_sp), N_cl),
counts = convert_counts(ts = ts, area_pop = area_pop, count_cells = count_cells, n_classes = n_classes, N_restricted = N_restricted, n_row_count = n_row_count, n_col_count = n_col_count),
infect = convert_infect(Y_hat = Y_hat, N_sp = N_sp, N_cl = N_cl),
lambda_0 = convert_pop(area_pop = area_pop, prop_class = prop_class, N_tm = N_tm, N_cl = N_cl, n_row_count = n_row_count, n_col_count = n_col_count) / cellarea)
if (null_model) {
if (!AR_include) {
formula <- counts ~ 1 + f(id_tm,  model = 'iid')  + f(id_sp, model = 'matern2d', nrow = n_row_count, ncol = n_col_count, nu = 1)
} else {
formula <- counts ~ 1 + f(id_tm,  model = 'iid')  + f(id_sp, model = 'matern2d', nrow = n_row_count, ncol = n_col_count, nu = 1) + f(id_tm2,  model = 'ar1')
}
} else {
if (!AR_include) {
formula <- counts ~ 0 + offset(log(infect * lambda_0)) + f(id_tm,  model = 'iid')  + f(id_sp, model = 'matern2d', nrow = n_row_count, ncol = n_col_count, nu = 1)
} else {
formula <- counts ~ 0 + offset(log(infect * lambda_0)) + f(id_tm,  model = 'iid')  + f(id_sp, model = 'matern2d', nrow = n_row_count, ncol = n_col_count, nu = 1) + f(id_tm2,  model = 'ar1')
# offset(log(infect * (lambda_0 / (cellarea * N_sp)))) # Which one is correct?
}
}
result <- inla(formula = formula,
family = 'poisson',
data = data_INLA,
# E = rep(cellarea, (N_sp * N_tm * N_cl)),
control.predictor = list(compute = TRUE, link = 1),
control.compute = list(config = TRUE),
verbose = verbose, safe = TRUE)
result
}
result <- fit_spatioTemporal(area_pop = area_pop, count_cells = count_cells, Y_hat = Y_hat, prop_class = prop_class, N_restricted = N_restricted, n_row_count = n_row_count, n_col_count = n_col_count, null_model = null_model, AR_include = AR_include)
processed_result <- process_result(result = result, area_pop = area_pop, n_row_count = n_row_count, n_col_count = n_col_count) # Unchanged
plot(processed_result$result_r_mean[[20]])
plot(intensities[[1]][[20]])
plot(processed_result$result_r_mean[[120]])
processed_result$result_r_mean[[120]]
zzz<-processed_result$result_r_mean[[120]]
zzz
sum(values(zzz) * cellarea)
SIR$SIR_sep[22, ]
zzz<-processed_result$result_r_mean[[20]]
SIR$SIR_sep[22, ]
sum(values(zzz) * cellarea)
fit_spatioTemporal <- function (area_pop, count_cells, Y_hat, N_restricted, n_row_count = 10, n_col_count = 30, null_model = TRUE, AR_include = FALSE, verbose = FALSE) {
ts <- 1:length(count_cells)
convert_counts <- function (ts, area_pop, count_cells, N_restricted, n_row_count, n_col_count) {
N <- length(count_cells)
ts <- ts[1:N_restricted]
progressbar <- txtProgressBar(min = 1, max = length(ts), initial = 1)
counts <- c()
for (t in ts) {
r <- raster(nrow = n_row_count, ncol = n_col_count)
extent(r) <- extent(area_pop)
r <- rasterize(x = count_cells[[t]], y = r, field = 'layer')
m <- matrix(data = values(r), nrow = n_row_count, ncol = n_col_count, byrow = TRUE)
counts <- c(counts, na.omit(as.vector(m)))
setTxtProgressBar(progressbar, t)
}
counts <- c(counts, rep(NA, nrow(count_cells[[1]]) * (N - length(ts))))
close(progressbar)
counts
}
convert_pop <- function (area_pop, N_tm, n_row_count, n_col_count) {
r <- raster(nrow = n_row_count, ncol = n_col_count)
extent(r) <- extent(area_pop)
mult_factor <- ((n_row_count / nrow(area_pop)) * (n_col_count / ncol(area_pop)))
m <- matrix(data = raster::extract(x = area_pop, y = rasterToPoints(r)), nrow = n_row_count, ncol = n_col_count, byrow = TRUE) / mult_factor
v <- na.omit(as.vector(m))
v <- rep(v, N_tm)
v / sum(v, na.rm = TRUE)
}
id_sp <- 1:nrow(count_cells[[1]]); N_sp <- length(id_sp)
id_tm <- ts; N_tm <- length(id_tm)
cellarea <- prod(res(area_pop)) / ((n_row_count / nrow(area_pop)) * (n_col_count / ncol(area_pop)))
print('Creating data object...')
data_INLA <- data.frame(id = 1:(N_sp * N_tm),
id_sp = rep(id_sp, N_tm),
id_tm = rep(id_tm, each = N_sp),
id_tm2 = rep(id_tm, each = N_sp),
counts = convert_counts(ts = ts, area_pop = area_pop, count_cells = count_cells, N_restricted = N_restricted, n_row_count = n_row_count, n_col_count = n_col_count),
infect = rep(apply(Y_hat, c(2, 3), mean)[, 2], each = N_sp),
lambda_0 = convert_pop(area_pop = area_pop, N_tm = N_tm, n_row_count = n_row_count, n_col_count = n_col_count) / cellarea)
if (null_model) {
if (!AR_include) {
formula <- counts ~ 1 + f(id_tm,  model = 'iid')  + f(id_sp, model = 'matern2d', nrow = n_row_count, ncol = n_col_count, nu = 1)
} else {
formula <- counts ~ 1 + f(id_tm,  model = 'iid')  + f(id_sp, model = 'matern2d', nrow = n_row_count, ncol = n_col_count, nu = 1) + f(id_tm2,  model = 'ar1')
}
} else {
if (!AR_include) {
formula <- counts ~ 0 + offset(log(infect * lambda_0)) + f(id_tm,  model = 'iid')  + f(id_sp, model = 'matern2d', nrow = n_row_count, ncol = n_col_count, nu = 1)
} else {
formula <- counts ~ 0 + offset(log(infect * lambda_0)) + f(id_tm,  model = 'iid')  + f(id_sp, model = 'matern2d', nrow = n_row_count, ncol = n_col_count, nu = 1) + f(id_tm2,  model = 'ar1')
}
}
result <- inla(formula = formula,
family = 'poisson',
data = data_INLA,
# E = rep(cellarea, (N_sp * N_tm)),
control.predictor = list(compute = TRUE, link = 1),
control.compute = list(config = TRUE),
verbose = verbose, safe = TRUE)
result
}
count_cells
Y_hat
fit_spatioTemporal <- function (area_pop, count_cells, Y_hat, N_restricted, n_row_count = 10, n_col_count = 30, null_model = TRUE, AR_include = FALSE, verbose = FALSE) {
ts <- 1:length(count_cells)
convert_counts <- function (ts, area_pop, count_cells, N_restricted, n_row_count, n_col_count) {
N <- length(count_cells)
ts <- ts[1:N_restricted]
progressbar <- txtProgressBar(min = 1, max = length(ts), initial = 1)
counts <- c()
for (t in ts) {
r <- raster(nrow = n_row_count, ncol = n_col_count)
extent(r) <- extent(area_pop)
r <- rasterize(x = count_cells[[t]], y = r, field = 'layer')
m <- matrix(data = values(r), nrow = n_row_count, ncol = n_col_count, byrow = TRUE)
counts <- c(counts, na.omit(as.vector(m)))
setTxtProgressBar(progressbar, t)
}
counts <- c(counts, rep(NA, nrow(count_cells[[1]]) * (N - length(ts))))
close(progressbar)
counts
}
convert_pop <- function (area_pop, N_tm, n_row_count, n_col_count) {
r <- raster(nrow = n_row_count, ncol = n_col_count)
extent(r) <- extent(area_pop)
mult_factor <- ((n_row_count / nrow(area_pop)) * (n_col_count / ncol(area_pop)))
m <- matrix(data = raster::extract(x = area_pop, y = rasterToPoints(r)), nrow = n_row_count, ncol = n_col_count, byrow = TRUE) / mult_factor
v <- na.omit(as.vector(m))
v <- rep(v, N_tm)
v / sum(v, na.rm = TRUE)
}
id_sp <- 1:nrow(count_cells[[1]]); N_sp <- length(id_sp)
id_tm <- ts; N_tm <- length(id_tm)
cellarea <- prod(res(area_pop)) / ((n_row_count / nrow(area_pop)) * (n_col_count / ncol(area_pop)))
print('Creating data object...')
data_INLA <- data.frame(id = 1:(N_sp * N_tm),
id_sp = rep(id_sp, N_tm),
id_tm = rep(id_tm, each = N_sp),
id_tm2 = rep(id_tm, each = N_sp),
counts = convert_counts(ts = ts, area_pop = area_pop, count_cells = count_cells, N_restricted = N_restricted, n_row_count = n_row_count, n_col_count = n_col_count),
infect = rep(apply(Y_hat, c(2, 3), mean)[, 2], each = N_sp),
lambda_0 = convert_pop(area_pop = area_pop, N_tm = N_tm, n_row_count = n_row_count, n_col_count = n_col_count) / cellarea)
if (null_model) {
if (!AR_include) {
formula <- counts ~ 1 + f(id_tm,  model = 'iid')  + f(id_sp, model = 'matern2d', nrow = n_row_count, ncol = n_col_count, nu = 1)
} else {
formula <- counts ~ 1 + f(id_tm,  model = 'iid')  + f(id_sp, model = 'matern2d', nrow = n_row_count, ncol = n_col_count, nu = 1) + f(id_tm2,  model = 'ar1')
}
} else {
if (!AR_include) {
formula <- counts ~ 0 + offset(log(infect * lambda_0)) + f(id_tm,  model = 'iid')  + f(id_sp, model = 'matern2d', nrow = n_row_count, ncol = n_col_count, nu = 1)
} else {
formula <- counts ~ 0 + offset(log(infect * lambda_0)) + f(id_tm,  model = 'iid')  + f(id_sp, model = 'matern2d', nrow = n_row_count, ncol = n_col_count, nu = 1) + f(id_tm2,  model = 'ar1')
}
}
result <- inla(formula = formula,
family = 'poisson',
data = data_INLA,
# E = rep(cellarea, (N_sp * N_tm)),
control.predictor = list(compute = TRUE, link = 1),
control.compute = list(config = TRUE),
verbose = verbose, safe = TRUE)
result
}
process_result <- function (result, area_pop, n_row_count, n_col_count) {
N_sp <- n_row_count * n_col_count
ts <- 1:(nrow(result$summary.fitted.values) / N_sp)
cellarea <- prod(res(area_pop)) / ((n_row_count / nrow(area_pop)) * (n_col_count / ncol(area_pop)))
convert_result <- function (area_pop, val, n_row_count, n_col_count) {
r <- raster(nrow = n_row_count, ncol = n_col_count)
extent(r) <- extent(area_pop)
mult_factor <- (n_row_count / nrow(area_pop)) * (n_col_count / ncol(area_pop))
values(r) <- raster::extract(x = area_pop, y = rasterToPoints(r)) /  mult_factor
m <- matrix(data = values(r), nrow = n_row_count, ncol = n_col_count, byrow = TRUE)
v <- as.vector(m)
v[which(!is.na(values(r)))] <- val
m <- matrix(data = v, nrow = n_row_count, ncol = n_col_count)
values(r) <- m
r
}
quant <- c('0.025quant', '0.975quant', 'mean')
fitted_values <- list()
result_r_0250 <- list()
result_r_0975 <- list()
result_r_mean <- list()
for (t in ts) {
fitted_values[[t]] <- result$summary.fitted.values[((t - 1) * N_sp + 1):((t) * N_sp), quant]  / cellarea
result_r_0250[[t]] <- convert_result(area_pop = area_pop, val = fitted_values[[t]][, 1], n_row_count = n_row_count, n_col_count = n_col_count)
result_r_0975[[t]] <- convert_result(area_pop = area_pop, val = fitted_values[[t]][, 2], n_row_count = n_row_count, n_col_count = n_col_count)
result_r_mean[[t]] <- convert_result(area_pop = area_pop, val = fitted_values[[t]][, 3], n_row_count = n_row_count, n_col_count = n_col_count)
}
list(result_r_0250 = result_r_0250, result_r_0975 = result_r_0975, result_r_mean = result_r_mean)
}
print(paste(sprintf('%02d', k), ' out of ', n_classes, sep = ''))
print(paste('Classes: ', sprintf('%02d', k), ' out of ', sprintf('%02d', n_classes), sep = ''))
result <- list()
processed_result()
result <- list()
processed_result <- list()
for (k in 1:n_classes) {
print(paste('Classes: ', sprintf('%02d', k), ' out of ', sprintf('%02d', n_classes), sep = ''))
area_pop_tmp <- area_pop
values(area_pop_tmp) <- values(area_pop) * prop_class[k]
result[[k]] <- fit_spatioTemporal(area_pop = area_pop_tmp, count_cells = count_cells[[k]], Y_hat = Y_hat, N_restricted = N_restricted, n_row_count = n_row_count, n_col_count = n_col_count, null_model = null_model, AR_include = AR_include)
processed_result[[k]] <- process_result(result = result[[k]], area_pop = area_pop_tmp[[k]], n_row_count = n_row_count, n_col_count = n_col_count) # Unchanged
}
k
processed_result[[k]] <- process_result(result = result[[k]], area_pop = area_pop_tmp[[k]], n_row_count = n_row_count, n_col_count = n_col_count) # Unchanged
result[[k]]
area_pop_tmp
plot(area_pop_tmp)
result[[k]]
area_pop_tmp[[k]]
processed_result[[k]] <- process_result(result = result[[k]], area_pop = area_pop_tmp, n_row_count = n_row_count, n_col_count = n_col_count) # Unchanged
result <- list()
processed_result <- list()
for (k in 1:n_classes) {
print(paste('Classes: ', sprintf('%02d', k), ' out of ', sprintf('%02d', n_classes), sep = ''))
area_pop_tmp <- area_pop
values(area_pop_tmp) <- values(area_pop) * prop_class[k]
result[[k]] <- fit_spatioTemporal(area_pop = area_pop_tmp, count_cells = count_cells[[k]], Y_hat = Y_hat, N_restricted = N_restricted, n_row_count = n_row_count, n_col_count = n_col_count, null_model = null_model, AR_include = AR_include)
processed_result[[k]] <- process_result(result = result[[k]], area_pop = area_pop_tmp, n_row_count = n_row_count, n_col_count = n_col_count) # Unchanged
}
result <- list()
processed_result <- list()
for (k in 1:n_classes) {
print(paste('Classes: ', sprintf('%02d', k), ' out of ', sprintf('%02d', n_classes), sep = ''))
area_pop_tmp <- area_pop
values(area_pop_tmp) <- values(area_pop) * prop_class[k]
Y_hat_tmp <- Y_hat[, , c(k, (n_classes + k), (n_classes * 2 + k))]
result[[k]] <- fit_spatioTemporal(area_pop = area_pop_tmp, count_cells = count_cells[[k]], Y_hat = Y_hat_tmp, N_restricted = N_restricted, n_row_count = n_row_count, n_col_count = n_col_count, null_model = null_model, AR_include = AR_include)
processed_result[[k]] <- process_result(result = result[[k]], area_pop = area_pop_tmp, n_row_count = n_row_count, n_col_count = n_col_count) # Unchanged
}
plot(intensities[[1]][[20]])
plot(intensities[[1]][[20]])
plot(processed_result[[1]]$result_r_mean[[20]])
cellarea
sum(values(intensities[[1]][[20]])*cellarea)
SIR$SIR_sep[20, ]
sum(values(processed_result[[1]]$result_r_mean[[20]])*cellarea)
plot(intensities[[2]][[20]])
plot(processed_result[[2]]$result_r_mean[[20]])
sum(values(intensities[[2]][[20]])*cellarea)
sum(values(processed_result[[2]]$result_r_mean[[20]])*cellarea)
SIR$SIR_sep[20, ]
saveRDS(object = count_cells, file = paste('output/', sprintf('%02d', s), '/rds/count_cells.rds', sep = ''))
saveRDS(object = result, file = paste('output/', sprintf('%02d', s), '/rds/result_spatioTemporal.rds', sep = ''))
saveRDS(object = processed_result, file = paste('output/', sprintf('%02d', s), '/rds/processed_result.rds', sep = ''))
intensities
results
result
k
results <- processed_result[[k]]$result_r_mean
N <- length(intensities)
errors <- c()
pts <- rasterToPoints(x = results[[1]])[, 1:2]
progressbar <- txtProgressBar(min = 1, max = N, initial = 1)
for (i in 1:N) {
int_val <- raster::extract(x = intensities[[i]], y = pts)
if (error_type == 'MAPE') {
errors <- c(errors,  compute_MAPE(int_val = int_val, res_val = values(results[[i]])))
} else if (error_type == 'MAAPE') {
errors <- c(errors, compute_MAAPE(int_val = int_val, res_val = values(results[[i]])))
}
setTxtProgressBar(progressbar, i)
}
extract
int_val <- raster::extract(x = intensities[[i]], y = pts)
progressbar <- txtProgressBar(min = 1, max = N, initial = 1)
for (i in 1:N) {
int_val <- raster::extract(x = intensities[[k]][[i]], y = pts)
if (error_type == 'MAPE') {
errors <- c(errors,  compute_MAPE(int_val = int_val, res_val = values(results[[i]])))
} else if (error_type == 'MAAPE') {
errors <- c(errors, compute_MAAPE(int_val = int_val, res_val = values(results[[i]])))
}
setTxtProgressBar(progressbar, i)
}
error_type = 'MAPE'
results <- processed_result[[k]]$result_r_mean
N <- length(intensities)
errors <- c()
pts <- rasterToPoints(x = results[[1]])[, 1:2]
progressbar <- txtProgressBar(min = 1, max = N, initial = 1)
for (i in 1:N) {
int_val <- raster::extract(x = intensities[[k]][[i]], y = pts)
if (error_type == 'MAPE') {
errors <- c(errors,  compute_MAPE(int_val = int_val, res_val = values(results[[i]])))
} else if (error_type == 'MAAPE') {
errors <- c(errors, compute_MAAPE(int_val = int_val, res_val = values(results[[i]])))
}
setTxtProgressBar(progressbar, i)
}
close(progressbar)
length(intensities)
n_classes <- length(intensities)
errors
errors
error_type = 'MAAPE'
error
erros
errors
compute_error <- function (intensities, processed_result, error_type = 'MAPE') {
n_classes <- length(intensities)
errors <- list()
for (k in 1:n_classes) {
results <- processed_result[[k]]$result_r_mean
N <- length(intensities)
error <- c()
pts <- rasterToPoints(x = results[[1]])[, 1:2]
progressbar <- txtProgressBar(min = 1, max = N, initial = 1)
for (i in 1:N) {
int_val <- raster::extract(x = intensities[[k]][[i]], y = pts)
if (error_type == 'MAPE') {
error <- c(error,  compute_MAPE(int_val = int_val, res_val = values(results[[i]])))
} else if (error_type == 'MAAPE') {
error <- c(error, compute_MAAPE(int_val = int_val, res_val = values(results[[i]])))
}
setTxtProgressBar(progressbar, i)
}
close(progressbar)
errors[[k]] <- error
}
errors
}
# plot_error(computed_error = computed_error_MAPE , s = s, error_type = 'MAPE' ) # PLOT
plot_error(computed_error = computed_error_MAAPE, s = s, error_type = 'MAAPE') # PLOT
compute_error <- function (intensities, processed_result, error_type = 'MAPE') {
n_classes <- length(intensities)
errors <- list()
for (k in 1:n_classes) {
results <- processed_result[[k]]$result_r_mean
N <- length(intensities)
error <- c()
pts <- rasterToPoints(x = results[[1]])[, 1:2]
progressbar <- txtProgressBar(min = 1, max = N, initial = 1)
for (i in 1:N) {
int_val <- raster::extract(x = intensities[[k]][[i]], y = pts)
if (error_type == 'MAPE') {
error <- c(error,  compute_MAPE(int_val = int_val, res_val = values(results[[i]])))
} else if (error_type == 'MAAPE') {
error <- c(error, compute_MAAPE(int_val = int_val, res_val = values(results[[i]])))
}
setTxtProgressBar(progressbar, i)
}
close(progressbar)
errors[[k]] <- error
}
errors
}
computed_error_MAPE  <- compute_error(intensities = intensities, processed_result = processed_result, error_type = 'MAPE' )
computed_error_MAAPE <- compute_error(intensities = intensities, processed_result = processed_result, error_type = 'MAAPE')
computed_error_MAPE
computed_error_MAAPE
compute_error <- function (intensities, processed_result, error_type = 'MAPE') {
n_classes <- length(intensities)
errors <- list()
for (k in 1:n_classes) {
results <- processed_result[[k]]$result_r_mean
N <- length(intensities[[k]])
error <- c()
pts <- rasterToPoints(x = results[[1]])[, 1:2]
progressbar <- txtProgressBar(min = 1, max = N, initial = 1)
for (i in 1:N) {
int_val <- raster::extract(x = intensities[[k]][[i]], y = pts)
if (error_type == 'MAPE') {
error <- c(error,  compute_MAPE(int_val = int_val, res_val = values(results[[i]])))
} else if (error_type == 'MAAPE') {
error <- c(error, compute_MAAPE(int_val = int_val, res_val = values(results[[i]])))
}
setTxtProgressBar(progressbar, i)
}
close(progressbar)
errors[[k]] <- error
}
errors
}
computed_error_MAPE  <- compute_error(intensities = intensities, processed_result = processed_result, error_type = 'MAPE' )
computed_error_MAAPE <- compute_error(intensities = intensities, processed_result = processed_result, error_type = 'MAAPE')
computed_error_MAPE
computed_error_MAAPE
selected_class
# plot_error(computed_error = computed_error_MAPE[[selected_class]], s = s, error_type = 'MAPE' ) # PLOT
plot_error(computed_error = computed_error_MAAPE[[selected_class]], s = s, error_type = 'MAAPE', save = F) # PLOT
selected_class <- 1
# plot_error(computed_error = computed_error_MAPE[[selected_class]], s = s, error_type = 'MAPE' ) # PLOT
plot_error(computed_error = computed_error_MAAPE[[selected_class]], s = s, error_type = 'MAAPE', save = F) # PLOT
# plot_error(computed_error = computed_error_MAPE[[selected_class]], s = s, error_type = 'MAPE' ) # PLOT
plot_error(computed_error = computed_error_MAAPE[[selected_class]], s = s, error_type = 'MAAPE', save = F) # PLOT
computed_error
# plot_error(computed_error = computed_error_MAPE[[selected_class]], s = s, error_type = 'MAPE' ) # PLOT
plot_error(computed_error = computed_error_MAAPE[[selected_class]], s = s, error_type = 'MAAPE') # PLOT
plot_error <- function (computed_error, selected_class, s, error_type = 'MAPE', save = TRUE) {
if (save) { png(filename = paste('output/', sprintf('%02d', s), '/plots/error_', error_type, '_class_', selected_class, '.png', sep = ''), width = 800, height = 600) }
par(family = 'LM Roman 10', mfrow = c(1, 1))
if (error_type == 'MAAPE') { y_max <- 1.58 } else { y_max <- max(computed_error) }
plot(computed_error, type = 'l', ylim = c(0, y_max), xlab = 'Time', ylab = error_type, main = paste(error_type, ' (', sprintf('%02d', s), ')', sep = ''))
# lines(computed_error, col = 'red')
abline(v = N_restricted, lty = 2)
# legend(x = 'topleft', legend = c('Alternative model', 'Null model'), col = c('black', 'red'), lty = 1)
if (save) { dev.off() }
}
# plot_error(computed_error = computed_error_MAPE[[selected_class]], s = s, error_type = 'MAPE' ) # PLOT
plot_error(computed_error = computed_error_MAAPE[[selected_class]], selected_class = selected_class, s = s, error_type = 'MAAPE') # PLOT
n_classes
computed_error_MAPE  <- compute_error(intensities = intensities, processed_result = processed_result, error_type = 'MAPE' )
computed_error_MAAPE <- compute_error(intensities = intensities, processed_result = processed_result, error_type = 'MAAPE')
for (k in 1:n_classes) {
# plot_error(computed_error = computed_error_MAPE[[k]],  selected_class = k, s = s, error_type = 'MAPE' ) # PLOT
plot_error(computed_error = computed_error_MAAPE[[k]], selected_class = k, s = s, error_type = 'MAAPE') # PLOT
}
sum(values(processed_result[[1]]$result_r_mean[[70]]) * cellarea)
sum(values(processed_result[[2]]$result_r_mean[[70]]) * cellarea)
SIR$SIR_sep[70, ]
sum(values(intensities[[1]][[70]]) * cellarea)
sum(values(intensities[[2]][[70]]) * cellarea)
